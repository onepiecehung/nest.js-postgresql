---
alwaysApply: false
---

@rule comments_contract
Entity `Comment` (current implementation):
- content (text), subjectType (varchar), subjectId (varchar), parentId (bigint FK, nullable)
- userId (bigint FK), type (enum), pinned (bool), edited (bool), editedAt (timestamp)
- visibility (enum), flags (json), metadata (json), replyCount (int, default 0)
- indexes: (subjectType, subjectId), (userId, createdAt), (parentId), (pinned, createdAt)

Related entities:
- CommentMedia: media attachments with sticker support
- CommentMention: user mentions in comments

Service config:
- entityName: 'Comment'; cache: { prefix: 'comments', ttlSec: 300, swrSec: 60 }
- defaultSearchField: 'content'
- getSearchableColumns(): ['content', 'subjectType']
- relationsWhitelist: { user: true, parent: true, replies: true, media: { media: true, sticker: { media: true } }, mentions: { user: true } }
- emitEvents: false (use RabbitMQ instead)

Controller routes:
- GET /comments -> list (offset pagination)
- GET /comments/cursor -> getCommentsCursor (cursor pagination)
- GET /comments/batch -> getBatch (multiple subjects)
- POST /comments -> @Auth() createComment
- PATCH /comments/:id -> @Auth() updateComment
- DELETE /comments/:id -> @Auth() deleteComment
- POST /comments/:id/pin -> @Auth() togglePin

@acceptance
- [ ] Parent chain validated; depth limited if required.
- [ ] No raw HTML injection; sanitized output path exists.
- [ ] Media attachments with sticker support.
- [ ] User mentions properly handled.
- [ ] Reply count maintained accurately.
- [ ] RabbitMQ events for async processing.
- [ ] Cache invalidation for subject-based queries.